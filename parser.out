Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMA
    ELSE
    FOR
    MAP
    SQMARK
    WHILE

Grammar

Rule 0     S' -> declarNum
Rule 1     declarNum -> NUM
Rule 2     declarNum -> INT
Rule 3     declarNum -> DOUBLE
Rule 4     declarNum -> VAR
Rule 5     declarNum -> DYNAMIC
Rule 6     resultado -> declarNum STRINGVAL ASSIGN NUMBER SEMICOLON
Rule 7     valor -> NUMBER
Rule 8     valor -> ID
Rule 9     resultado -> valor PLUS valor SEMICOLON
Rule 10    resultado -> valor MINUS valor SEMICOLON
Rule 11    resultado -> valor TIMES valor SEMICOLON
Rule 12    resultado -> valor DIVIDE valor SEMICOLON
Rule 13    string -> declarar STRINGVAL SEMICOLON
Rule 14    declarar -> VAR
Rule 15    declarar -> STRING
Rule 16    declarar -> DYNAMIC
Rule 17    declaracion_booleana -> BOOL STRINGVAL ASSIGN booleano SEMICOLON
Rule 18    booleano -> TRUE
Rule 19    booleano -> FALSE
Rule 20    imprimir -> PRINT LPAREN opciones RPAREN SEMICOLON
Rule 21    opciones -> LDQMARK STRINGVAL RDQMARK
Rule 22    opciones -> STRINGVAL
Rule 23    tipo -> NUM
Rule 24    tipo -> INT
Rule 25    tipo -> STRING
Rule 26    tipo -> DOUBLE
Rule 27    tipo -> VAR
Rule 28    tipo -> DYNAMIC
Rule 29    agregar -> STRINGVAL PUNTO ADD LPAREN LDQMARK ID RDQMARK RPAREN SEMICOLON
Rule 30    lista -> LIST LESSTHAN tipo MORETHAN STRINGVAL SEMICOLON
Rule 31    conjuntos -> SET STRINGVAL ASSIGN NEW SET LPAREN RPAREN SEMICOLON
Rule 32    if -> IF LPAREN ID opcionesIf valor RPAREN LBRACE RBRACE SEMICOLON
Rule 33    opcionesIf -> LESSTHAN
Rule 34    opcionesIf -> MORETHAN
Rule 35    opcionesIf -> GQUAL
Rule 36    opcionesIf -> LQUAL
Rule 37    opcionesIf -> NOTEQUALS
Rule 38    opcionesIf -> EQUALS

Terminals, with rules where they appear

ADD                  : 29
ASSIGN               : 6 17 31
BOOL                 : 17
COMMA                : 
DIVIDE               : 12
DOUBLE               : 3 26
DYNAMIC              : 5 16 28
ELSE                 : 
EQUALS               : 38
FALSE                : 19
FOR                  : 
GQUAL                : 35
ID                   : 8 29 32
IF                   : 32
INT                  : 2 24
LBRACE               : 32
LDQMARK              : 21 29
LESSTHAN             : 30 33
LIST                 : 30
LPAREN               : 20 29 31 32
LQUAL                : 36
MAP                  : 
MINUS                : 10
MORETHAN             : 30 34
NEW                  : 31
NOTEQUALS            : 37
NUM                  : 1 23
NUMBER               : 6 7
PLUS                 : 9
PRINT                : 20
PUNTO                : 29
RBRACE               : 32
RDQMARK              : 21 29
RPAREN               : 20 29 31 32
SEMICOLON            : 6 9 10 11 12 13 17 20 29 30 31 32
SET                  : 31 31
SQMARK               : 
STRING               : 15 25
STRINGVAL            : 6 13 17 21 22 29 30 31
TIMES                : 11
TRUE                 : 18
VAR                  : 4 14 27
WHILE                : 
error                : 

Nonterminals, with rules where they appear

agregar              : 
booleano             : 17
conjuntos            : 
declarNum            : 6 0
declaracion_booleana : 
declarar             : 13
if                   : 
imprimir             : 
lista                : 
opciones             : 20
opcionesIf           : 32
resultado            : 
string               : 
tipo                 : 30
valor                : 9 9 10 10 11 11 12 12 32

Parsing method: LALR

state 0

    (0) S' -> . declarNum
    (1) declarNum -> . NUM
    (2) declarNum -> . INT
    (3) declarNum -> . DOUBLE
    (4) declarNum -> . VAR
    (5) declarNum -> . DYNAMIC

    NUM             shift and go to state 2
    INT             shift and go to state 3
    DOUBLE          shift and go to state 4
    VAR             shift and go to state 5
    DYNAMIC         shift and go to state 6

    declarNum                      shift and go to state 1

state 1

    (0) S' -> declarNum .



state 2

    (1) declarNum -> NUM .

    $end            reduce using rule 1 (declarNum -> NUM .)


state 3

    (2) declarNum -> INT .

    $end            reduce using rule 2 (declarNum -> INT .)


state 4

    (3) declarNum -> DOUBLE .

    $end            reduce using rule 3 (declarNum -> DOUBLE .)


state 5

    (4) declarNum -> VAR .

    $end            reduce using rule 4 (declarNum -> VAR .)


state 6

    (5) declarNum -> DYNAMIC .

    $end            reduce using rule 5 (declarNum -> DYNAMIC .)

